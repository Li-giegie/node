## 下文将演示多节点桥接场景
节点结构图
```
├─node-10
│    ├─node-11
│    └─node 20*
├─node-20
│    ├─node-21
│    ├─node-10*
│    └─node 30*
├─node-30
│    ├─node-31
│    ├─node-20*
│    └─node 40*
└─node-40
     ├─node-30*
     └─node 41
```

### 启动服务端节点
节点开启：节点动态发现协议、hell心跳检测协议

启动节点：10、20、30、40

node/example/bridge/server
```go
go run ./ -id 10 -addr 127.0.0.1:8010
go run ./ -id 20 -addr 127.0.0.1:8020
go run ./ -id 30 -addr 127.0.0.1:8030
go run ./ -id 40 -addr 127.0.0.1:8040
```
#### 命令列表 
- help
- bind 绑定一个服务端节点
- list 输出连接信息信息、或节点路由信息
- request 发送消息，并希望在限定时间内得到一个回复
- write 发送数据

更具体的用法每条命令下输入help可查看用法

### 桥接服务端节点

绑定的顺序为：10 到 20 到 30 到 40
依次在每个服务端节点中执行如下命令
```
10节点执行
bind -addr 127.0.0.1:8020 -id 20
20节点执行
bind -addr 127.0.0.1:8030 -id 30
30节点执行
bind -addr 127.0.0.1:8040 -id 40
```
验证绑定节点
在每个节点输入 'list conn'

10 节点输入节点列表
```
0 20
```
### 启动客户端节点
节点开启：hell心跳检测

启动节点：11、21、31、41

node/example/bridge/client
```go
go run ./ -lid 11 -rid 10 -raddr 0.0.0.0:8010
go run ./ -lid 21 -rid 20 -raddr 0.0.0.0:8020
go run ./ -lid 31 -rid 30 -raddr 0.0.0.0:8030
go run ./ -lid 41 -rid 40 -raddr 0.0.0.0:8040
```
#### 客户端节点命令列表
- help 帮助信息
- request 发送数据，并希望再限定时间内得到回复
- write 发送数据

### 命令演示
#### 服务端节点中查看连接
在节点10中执行：list conn
```
0 20
1 11
```
得到第一个数字为序号、第二个为节点Id，共有三个连接，分别为1、2、20

这里的连接都是直连连接，并不包含所有可以到达的连接，可到达的连接是直连连接加路由可到达的连接

#### 在服务端节点中查看路由

#### 发送请求
当前节点不能跟当前节点发送请求 

在节点10上执行
```
request -id 11 hello
//回复 from 11 echo hello
```
在节点10中执行：list route

此时路由为空，路由是懒计算的，也就是每次用到时才会计算

直连连接加路由就是能够到达的所有节点

```
request -id 41 hello
//回复 from 41 echo hello
```
由于41节点不是直连节点，所以计算了路由，再次查询路由就可以查到41的路由信息了
```
list route

dst 41 via 20 date-time 2024-11-25 13:59:06 hop 4 full-path [10 20 30 31 41]
目的地  下一跳  日期时间                       跳数   全路径 
```